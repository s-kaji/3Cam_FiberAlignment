//
// File generated by HDevelop for HALCON/.NET (C#) Version 12.0.3
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using System.Windows.Forms;
using HalconDotNet;

public partial class HDevelopExport2
{
    public HTuple hv_ExpDefaultWinHandle;
    private bool loopstop = false;

    //画像処理
    public double dip;          //傾き      

    public HTuple hv_maker = null;                  //カメラメーカ
    public HTuple hv_resoH = new HTuple();          //画像サイズ：高さ
    public HTuple hv_resoW = new HTuple();          //画像サイズ：幅
    public HTuple hv_number = null;                 //カメラ番号
    public HTuple hv_gain = new HTuple();           //ゲイン
    public HTuple hv_exposure = new HTuple();       //露出時間
    public HTuple hv_digital_gain = new HTuple();   //デジタルゲイン
    public HTuple hv_mirror = null;                 //鏡面

    public void HDevelopStop()
    {
        loopstop = true;
        //MessageBox.Show("Press button to continue", "Program stop");
    }

    // Procedures 
    // Main procedure 
    private void action()
    {
        // Local iconic variables 

        HObject ho_Image = null, ho_GrayImage = null, ho_Edges = null;
        HObject ho_ImageMirror = null, ho_ImageMirrorRow = null;
        HObject ho_ContoursSplit = null;

        // Local control variables 

        HTuple hv_AcqHandle = null, hv_RowBegin = new HTuple();
        HTuple hv_ColBegin = new HTuple(), hv_RowEnd = new HTuple();
        HTuple hv_ColEnd = new HTuple(), hv_Nr = new HTuple();
        HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_RowCenter = new HTuple();
        HTuple hv_ColCenter = new HTuple(), hv_Length = new HTuple();
        HTuple hv_Phi1 = new HTuple(), hv_Phi2 = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_ImageMirror);
        HOperatorSet.GenEmptyObj(out ho_ImageMirrorRow);
        HOperatorSet.GenEmptyObj(out ho_GrayImage);
        HOperatorSet.GenEmptyObj(out ho_Edges);
        HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
        try
        {
            //Image Acquisition 01: Code generated by Image Acquisition 01
            HOperatorSet.OpenFramegrabber(hv_maker, 1, 1, 0, 0, 0, 0, "progressive", 8,
                "default", -1, "false", "default", hv_number, 0, -1, out hv_AcqHandle);
            HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "bayer_pattern", "gbrg");
            HOperatorSet.GrabImageStart(hv_AcqHandle, -1);

            bool AlignmentEnable = false;
            while (!loopstop)
            {
                //Application.DoEvents();     //
                HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "digital_gain", hv_digital_gain);
                HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "gain", hv_gain);
                HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "exposure", hv_exposure);
                ho_Image.Dispose();
                HOperatorSet.GrabImageAsync(out ho_Image, hv_AcqHandle, -1);
                if (hv_mirror != "")
                {
                    ho_ImageMirror.Dispose();
                    if (hv_mirror == "diagonal")
                    {
                        ho_ImageMirrorRow.Dispose();
                        HOperatorSet.MirrorImage(ho_Image, out ho_ImageMirrorRow, "row");
                        HOperatorSet.MirrorImage(ho_ImageMirrorRow, out ho_ImageMirror, "column");
                    }
                    else
                    {
                        HOperatorSet.MirrorImage(ho_Image, out ho_ImageMirror, hv_mirror);
                    }
                    HOperatorSet.DispObj(ho_ImageMirror, hv_ExpDefaultWinHandle);
                }
                else
                {
                    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
                    ho_ImageMirror = ho_Image;
                }

                if (AlignmentEnable)
                {
                    ho_GrayImage.Dispose();
                    HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
                    //HOperatorSet.DispObj(ho_GrayImage, hv_ExpDefaultWinHandle);
                    ho_Edges.Dispose();
                    HOperatorSet.EdgesSubPix(ho_Image, out ho_Edges, "canny", 15, 50, 100);

                    ho_ContoursSplit.Dispose();
                    //MaxLineDist1, MaxLineDist2を小さい値にすると線検出が細かくなる
                    HOperatorSet.SegmentContoursXld(ho_Edges, out ho_ContoursSplit, "lines",
                        50, 10, 10);
                    HOperatorSet.FitLineContourXld(ho_ContoursSplit, "huber", -1, 0, 5, 1, out hv_RowBegin,
                        out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc,
                        out hv_Dist);
                    HOperatorSet.LinePosition(hv_RowBegin, hv_ColBegin, hv_RowEnd, hv_ColEnd,
                        out hv_RowCenter, out hv_ColCenter, out hv_Length, out hv_Phi1);
                    hv_Phi2 = (hv_Phi1 * 180) / 3.14159;

                    double Length_max1 = 0;
                    double Length_max2 = 0;
                    double Phi_max1 = 0;
                    double Phi_max2 = 0;

                    int DataLength = (int)(new HTuple(hv_Length.TupleLength()));
                    if (DataLength != 0)
                    {
                        for (int i = 0; i < DataLength; i++)
                        {
                            if (Math.Abs((double)hv_Phi2[i]) < 7)
                            {
                                if (hv_Length[i] > Length_max2)
                                {
                                    if (hv_Length[i] > Length_max1)
                                    {
                                        Length_max2 = Length_max1;
                                        Phi_max2 = Phi_max1;
                                        Length_max1 = hv_Length[i];
                                        Phi_max1 = hv_Phi2[i];
                                    }
                                    else
                                    {
                                        Length_max2 = hv_Length[i];
                                        Phi_max2 = hv_Phi2[i];
                                    }
                                }
                            }
                        }
                        dip = (Phi_max1 + Phi_max2) / 2;

                        //HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
                        HOperatorSet.SetColored(hv_ExpDefaultWinHandle, 6);
                        HOperatorSet.DispObj(ho_Edges, hv_ExpDefaultWinHandle);
                    }
                }
                System.Threading.Thread.Sleep(100);
            }
            HOperatorSet.CloseFramegrabber(hv_AcqHandle);
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            ho_ImageMirror.Dispose();
            ho_ImageMirrorRow.Dispose();
            ho_GrayImage.Dispose();
            ho_Edges.Dispose();
            ho_ContoursSplit.Dispose();

            MessageBox.Show(HDevExpDefaultException.Message);
            //throw HDevExpDefaultException;
        }
        ho_Image.Dispose();
        ho_ImageMirror.Dispose();
        ho_ImageMirrorRow.Dispose();
        ho_GrayImage.Dispose();
        ho_Edges.Dispose();
        ho_ContoursSplit.Dispose();
    }

    public void InitHalcon()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", hv_resoW);
        HOperatorSet.SetSystem("height", hv_resoH);
        //HOperatorSet.SetSystem("width", 2592);
        //HOperatorSet.SetSystem("height", 1944);
    }

    public void RunHalcon(HTuple Window)
    {
        //loopstop = _3Cam_FiberAlignment.FormMain.Instance.chkCAM2.Checked;
        loopstop = false;
        hv_ExpDefaultWinHandle = Window;
        action();
    }

}
